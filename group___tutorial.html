<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DIY: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DIY
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">data-parallel out-of-core C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial</div>  </div>
</div><!--header-->
<div class="contents">
<h2>Getting started</h2>
<p>The following is an example of the steps needed to initialize DIY.</p>
<h3>Block</h3>
<p>The block is the basic unit of everything (data, decomposition, communication) in DIY. Use it to define your data model and any state associated with the data that will be needed to accompany the data throughout its lifetime. In addition to the data in the block, it should define functions to <code>create</code> and <code>destroy</code> the block that DIY can call. If the blocks are intended to be moved in and out of core, then the block must also define <code>save</code> and <code>load</code> functions.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()                                    { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)                            { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">save</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* b, <a class="code" href="structdiy_1_1_binary_buffer.html">diy::BinaryBuffer</a>&amp; bb)  { <a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a>(bb, *static_cast&lt;const Block*&gt;(b)); }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">load</a>(<span class="keywordtype">void</span>* b, <a class="code" href="structdiy_1_1_binary_buffer.html">diy::BinaryBuffer</a>&amp; bb)        { <a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>(bb, *static_cast&lt;Block*&gt;(b)); }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// other functions and data members</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3>Master</h3>
<p><a class="el" href="classdiy_1_1_master.html">diy::Master</a> owns and manages the blocks. To set up a <code>Master</code> object, first define the MPI communicator and the file storage object (if blocks will be moved in and out of core), which you pass to the <code>Master</code> constructor. The <code>Master</code> manages loading/saving blocks, executing their callback functions, and exchanging data between them.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classdiy_1_1mpi_1_1communicator.html">diy::mpi::communicator</a>    world(comm);</div>
<div class="line">  <a class="code" href="classdiy_1_1_file_storage.html">diy::FileStorage</a>          storage(<span class="stringliteral">&quot;./DIY.XXXXXX&quot;</span>);</div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                                   num_threads,</div>
<div class="line">                                   mem_blocks,</div>
<div class="line">                                   &amp;Block::create,</div>
<div class="line">                                   &amp;Block::destroy,</div>
<div class="line">                                   &amp;storage,</div>
<div class="line">                                   &amp;<a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">Block::save</a>,</div>
<div class="line">                                   &amp;<a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">Block::load</a>);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Some of the arguments to the constructor are optional. If all blocks are to remain in memory, there is a shorter form of the <code>Master</code> constructor that can be used, since there is no need to specify most of the arguments because they relate to block loading/unloading.</p>
<div class="fragment"><div class="line"><a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                                 num_threads);</div>
</div><!-- fragment --><h3>Assigner</h3>
<p><a class="el" href="classdiy_1_1_assigner.html">diy::Assigner</a> is an auxiliary object that determines what blocks lives on what MPI process. Blocks can be assigned to processes contiguously or in round-robin fashion:</p>
<div class="fragment"><div class="line"><a class="code" href="classdiy_1_1_contiguous_assigner.html">diy::ContiguousAssigner</a>   assigner(world.size(),   <span class="comment">// total number of MPI ranks</span></div>
<div class="line">                                   nblocks);       <span class="comment">// total number of blocks in global domain</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// --- or ---</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classdiy_1_1_round_robin_assigner.html">diy::RoundRobinAssigner</a>   assigner(world.size(),</div>
<div class="line">                                   nblocks);</div>
</div><!-- fragment --><h3>Decomposition</h3>
<p>Any custom decomposition can be formed by assigning links (communication neighborhoods of blocks) manually. However, for a regular grid of blocks, DIY provides a regular decomposition of blocks with either continuous (floating-point extents that share common boundaries) or discrete (integer extents that may or may not overlap) bounds.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span>  <a class="code" href="structdiy_1_1_bounds.html">diy::ContinuousBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularContinuousLink</a>  RCLink;</div>
<div class="line"></div>
<div class="line"><span class="comment">// --- or ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="structdiy_1_1_bounds.html">diy::DiscreteBounds</a>         Bounds;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularGridLink</a>        RGLink;</div>
</div><!-- fragment --><p><code>RegularDecomposer</code> helps decompose a domain into a regular grid of blocks. It's initialized with the dimension of the domain, its extents, and the number of blocks used in the decomposition.</p>
<div class="fragment"><div class="line"><a class="code" href="structdiy_1_1_regular_decomposer.html">diy::RegularDecomposer&lt;Bounds&gt;</a> decomposer(dim,</div>
<div class="line">                                          domain,</div>
<div class="line">                                          nblocks);</div>
</div><!-- fragment --><p>Its member function <code>decompose</code> performs the actual decomposition. Besides the local MPI rank and an instance of <code>Assigner</code>, it takes a callback responsible for creating the block and adding it to a <code>Master</code>. In C++11, it's convenient to use a lambda function for this purpose.</p>
<div class="fragment"><div class="line">decomposer.decompose(rank, assigner,</div>
<div class="line">                     [&amp;](<span class="keywordtype">int</span> gid,                   <span class="comment">// block global id</span></div>
<div class="line">                         <span class="keyword">const</span> Bounds&amp; core,        <span class="comment">// block bounds without any ghost added</span></div>
<div class="line">                         <span class="keyword">const</span> Bounds&amp; bounds,      <span class="comment">// block bounds including any ghost region added</span></div>
<div class="line">                         <span class="keyword">const</span> Bounds&amp; domain,      <span class="comment">// global data bounds</span></div>
<div class="line">                         <span class="keyword">const</span> RCLink&amp; link)        <span class="comment">// neighborhood</span></div>
<div class="line">                     {</div>
<div class="line">                         Block*          b   = <span class="keyword">new</span> Block;             <span class="comment">// possibly use custom initialization</span></div>
<div class="line">                         RGLink*         l   = <span class="keyword">new</span> RGLink(link);</div>
<div class="line">                         <span class="keywordtype">int</span>             lid = master.add(gid, b, l); <span class="comment">// add block to the master (mandatory)</span></div>
<div class="line"></div>
<div class="line">                         <span class="comment">// process any additional args here, load the data, etc.</span></div>
<div class="line">                     });</div>
</div><!-- fragment --><p>A shorter form is provided, if you only want to add the blocks to <code>Master</code>, without any additional processing.</p>
<div class="fragment"><div class="line">decomposer.decompose(rank,</div>
<div class="line">                     assigner,</div>
<div class="line">                     master);</div>
</div><!-- fragment --><h3>Combined code</h3>
<p>Here is one version of each of the above options combined into a complete program. This example uses the short form of blocks:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/decomposition.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/assigner.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="structdiy_1_1_bounds.html">diy::DiscreteBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularGridLink</a>      RGLink;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  Block() {}</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()            { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)    { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="structdiy_1_1mpi_1_1environment.html">diy::mpi::environment</a>     env(argc, argv);             <span class="comment">// diy&#39;s version of MPI_Init</span></div>
<div class="line">  <a class="code" href="classdiy_1_1mpi_1_1communicator.html">diy::mpi::communicator</a>    world;                       <span class="comment">// diy&#39;s version of MPI communicator</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span>                       dim     = 3;                 <span class="comment">// dimensionality</span></div>
<div class="line">  <span class="keywordtype">int</span>                       size    = 8;                 <span class="comment">// total number of MPI ranks</span></div>
<div class="line">  <span class="keywordtype">int</span>                       nblocks = 32;                <span class="comment">// total number of blocks in global domain</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_contiguous_assigner.html">diy::ContiguousAssigner</a>   assigner(size, nblocks);</div>
<div class="line">  Bounds domain;                                         <span class="comment">// global data size</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                            1,                           <span class="comment">// 1 thread in this example</span></div>
<div class="line">                            -1,                          <span class="comment">// all blocks in memory in this example</span></div>
<div class="line">                            &amp;Block::create,              <span class="comment">// block create function</span></div>
<div class="line">                            &amp;Block::destroy);            <span class="comment">// block destroy function</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="structdiy_1_1_regular_decomposer.html">diy::RegularDecomposer&lt;Bounds&gt;</a> decomposer(dim,</div>
<div class="line">                                            domain,      <span class="comment">// global domain size</span></div>
<div class="line">                                            nblocks);</div>
<div class="line">  decomposer.decompose(world.rank(),                     <span class="comment">// MPI rank of this process</span></div>
<div class="line">                       assigner,                         <span class="comment">// assigner object</span></div>
<div class="line">                       master);                          <span class="comment">// master object</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Below is one more complete example, using a lambda function to initialize the block:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/decomposition.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/assigner.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="structdiy_1_1_bounds.html">diy::DiscreteBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularGridLink</a>      RGLink;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  Block() {}</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()            { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)    { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="structdiy_1_1mpi_1_1environment.html">diy::mpi::environment</a>     env(argc, argv);             <span class="comment">// diy&#39;s version of MPI_Init</span></div>
<div class="line">  <a class="code" href="classdiy_1_1mpi_1_1communicator.html">diy::mpi::communicator</a>    world;                       <span class="comment">// diy&#39;s version of MPI communicator</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span>                       dim     = 3;                 <span class="comment">// dimensionality</span></div>
<div class="line">  <span class="keywordtype">int</span>                       size    = 8;                 <span class="comment">// total number of MPI ranks</span></div>
<div class="line">  <span class="keywordtype">int</span>                       nblocks = 32;                <span class="comment">// total number of blocks in global domain</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_contiguous_assigner.html">diy::ContiguousAssigner</a>   assigner(size, nblocks);</div>
<div class="line">  Bounds domain;                                         <span class="comment">// global data size</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                            1,                           <span class="comment">// 1 thread in this example</span></div>
<div class="line">                            -1,                          <span class="comment">// all blocks in memory in this example</span></div>
<div class="line">                            &amp;Block::create,              <span class="comment">// block create function</span></div>
<div class="line">                            &amp;Block::destroy);            <span class="comment">// block destroy function</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="structdiy_1_1_regular_decomposer.html">diy::RegularDecomposer&lt;Bounds&gt;</a> decomposer(dim,</div>
<div class="line">                                            domain,      <span class="comment">// global domain size</span></div>
<div class="line">                                            nblocks);</div>
<div class="line">  decomposer.decompose(world.rank(),                     <span class="comment">// MPI rank of this process</span></div>
<div class="line">                       assigner,                         <span class="comment">// assigner object</span></div>
<div class="line">                       [&amp;](<span class="keywordtype">int</span> gid,                      <span class="comment">// block global id</span></div>
<div class="line">                           <span class="keyword">const</span> Bounds&amp; core,           <span class="comment">// block bounds without any ghost added</span></div>
<div class="line">                           <span class="keyword">const</span> Bounds&amp; bounds,         <span class="comment">// block bounds including any ghost region added</span></div>
<div class="line">                           <span class="keyword">const</span> Bounds&amp; domain,         <span class="comment">// global data bounds</span></div>
<div class="line">                           <span class="keyword">const</span> RCLink&amp; link)           <span class="comment">// neighborhood</span></div>
<div class="line">                       {</div>
<div class="line">                           Block*  b   = <span class="keyword">new</span> Block;             <span class="comment">// possibly use custom initialization</span></div>
<div class="line">                           RGLink* l   = <span class="keyword">new</span> RGLink(link);</div>
<div class="line">                           <span class="keywordtype">int</span>     lid = master.add(gid, b, l); <span class="comment">// add block to the master (mandatory)</span></div>
<div class="line">                       });</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classdiy_1_1_master.html">diy::Master</a> API has a separate documentation page. The <code>RegularDecomposer</code> is documented in the <a class="el" href="group___decomposition.html">Decomposition</a> page. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 4 2019 20:34:01 for DIY by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
