<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DIY: Initialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DIY
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">data-parallel out-of-core C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Initialization</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2>Getting started</h2>
<p>The following is an example of the steps needed to initialize diy:</p>
<h3>Start with a definition of a block.</h3>
<p>The block is the basic unit of everything (data, decomposition, communication) in diy. Use it to define your data model and any state associated with the data that will be needed to accompany the data throughout its lifetime. In addition to the data in the block, it should define functions to <code>create</code> and <code>destroy</code> the block that diy can call. If the blocks are intended to be moved in and out of core, then the block must also define <code>save</code> and <code>load</code> functions.</p>
<p>There are 2 common ways to set up the block.</p>
<ul>
<li>The "short form" is used when blocks do not need any arguments when created. Here is an example:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()                                    { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)                            { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">save</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* b, <a class="code" href="structdiy_1_1_binary_buffer.html">diy::BinaryBuffer</a>&amp; bb)</div>
<div class="line">    { <a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a>(bb, *static_cast&lt;const Block*&gt;(b)); }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">load</a>(<span class="keywordtype">void</span>* b, <a class="code" href="structdiy_1_1_binary_buffer.html">diy::BinaryBuffer</a>&amp; bb)</div>
<div class="line">    { <a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>(bb, *static_cast&lt;Block*&gt;(b)); }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// other functions and data members</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>The "long form" is used when custom arguments are needed to initialize blocks upon creation. This saves one I/O cycle if blocks are moved in and out of core and also provides useful information to the block such as the bounds. A second object called <code>AddBlock</code> is a functor that gets and stores any custom arguments and overloads the function call with access to the custom arguments:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="structdiy_1_1_bounds.html">diy::ContinuousBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularContinuousLink</a>  RCLink;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()                                    { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)                            { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">save</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* b, <a class="code" href="structdiy_1_1_binary_buffer.html">diy::BinaryBuffer</a>&amp; bb)</div>
<div class="line">    { <a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a>(bb, *static_cast&lt;const Block*&gt;(b)); }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">load</a>(<span class="keywordtype">void</span>* b, <a class="code" href="structdiy_1_1_binary_buffer.html">diy::BinaryBuffer</a>&amp; bb)</div>
<div class="line">    { <a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>(bb, *static_cast&lt;Block*&gt;(b)); }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// other functions and data members</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>AddBlock</div>
<div class="line">{</div>
<div class="line">  AddBlock(<a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp; master_) : master(master_) {}   <span class="comment">// additional args as needed</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// this is the function that is needed for diy::decompose</span></div>
<div class="line">  <span class="keywordtype">void</span>  operator()(<span class="keywordtype">int</span> gid,                   <span class="comment">// block global id</span></div>
<div class="line">                   <span class="keyword">const</span> Bounds&amp; core,        <span class="comment">// block bounds without any ghost added</span></div>
<div class="line">                   <span class="keyword">const</span> Bounds&amp; bounds,      <span class="comment">// block bounds including any ghost region added</span></div>
<div class="line">                   <span class="keyword">const</span> Bounds&amp; domain,      <span class="comment">// global data bounds</span></div>
<div class="line">                   <span class="keyword">const</span> RCLink&amp; link)        <span class="comment">// neighborhood</span><span class="keyword"></span></div>
<div class="line"><span class="keyword">    const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      Block*          b   = <span class="keyword">new</span> Block();</div>
<div class="line">      RGLink*         l   = <span class="keyword">new</span> RGLink(link);</div>
<div class="line">      <a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp;    m   = <span class="keyword">const_cast&lt;</span><a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp;<span class="keyword">&gt;</span>(master);</div>
<div class="line">      <span class="keywordtype">int</span>             lid = m.<a class="code" href="classdiy_1_1_master.html#aeab2723bb0ecd4f7316b4805c1b53a61">add</a>(gid, b, l); <span class="comment">// add block to the master (mandatory)</span></div>
<div class="line">      <span class="comment">// process any additional args here, using them to initialize the block</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp;  master;</div>
<div class="line">  <span class="comment">// store additional args here</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3>Create the master object.</h3>
<p>Define your global data bounds, the MPI communicator, and the file storage object (if blocks will be moved in and out of core). Then define the diy <code>Master</code> object. The <code>Master</code> manages loading/saving blocks, executing their callback functions, and exchanging data between them. If the block long form (with <code>AddBlock</code> functor) is used, define the <code>AddBlock</code> object as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line"></div>
<div class="line">  <a class="code" href="structdiy_1_1_bounds.html">diy::Bounds</a>               domain;</div>
<div class="line">  <a class="code" href="classdiy_1_1mpi_1_1communicator.html">diy::mpi::communicator</a>    world(comm);</div>
<div class="line">  <a class="code" href="classdiy_1_1_file_storage.html">diy::FileStorage</a>          storage(<span class="stringliteral">&quot;./DIY.XXXXXX&quot;</span>);</div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                                   num_threads,</div>
<div class="line">                                   mem_blocks,</div>
<div class="line">                                   &amp;Block::create,</div>
<div class="line">                                   &amp;Block::destroy,</div>
<div class="line">                                   &amp;storage,</div>
<div class="line">                                   &amp;<a class="code" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">Block::save</a>,</div>
<div class="line">                                   &amp;<a class="code" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">Block::load</a>);</div>
<div class="line">  <span class="comment">// if AddBlock is used (block long form), then:</span></div>
<div class="line">  AddBlock                  addblock(master) <span class="comment">// could have extra args</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>When all blocks will remain in memory, there is a shorter form of the <code>Master</code> constructor that can be used. In this case there is no need to specify most of the arguments because they relate to block loading/unloading.</p>
<div class="fragment"><div class="line"><a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                                 num_threads);</div>
</div><!-- fragment --><h3>Assign blocks to processes.</h3>
<p>Blocks can be assigned to processes contiguously or in round-robin fashion:</p>
<div class="fragment"><div class="line"><a class="code" href="classdiy_1_1_contiguous_assigner.html">diy::ContiguousAssigner</a>   assigner(world.size(),   <span class="comment">// total number of MPI ranks</span></div>
<div class="line">                                   nblocks);       <span class="comment">// total number of blocks in global domain</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// --- or ---</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classdiy_1_1_round_robin_assigner.html">diy::RoundRobinAssigner</a>   assigner(world.size(),</div>
<div class="line">                                   nblocks);</div>
</div><!-- fragment --><h3>Decompose the domain.</h3>
<p>Any custom decomposition can be formed by assigning links (communication neighborhoods of blocks) manually. However, for a regular grid of blocks, diy provides a regular decomposition of blocks with either continuous (floating-point extents that share common boundaries) or discrete (integer extents that may or may not overlap) bounds.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span>  <a class="code" href="structdiy_1_1_bounds.html">diy::ContinuousBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularContinuousLink</a>  RCLink;</div>
<div class="line"></div>
<div class="line"><span class="comment">// --- or ---</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="structdiy_1_1_bounds.html">diy::DiscreteBounds</a>         Bounds;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularGridLink</a>        RGLink;</div>
</div><!-- fragment --><p>Diy offers two versions of a <code>decompose</code> function, depending on whether the short or long form of the block is used. Recall that the long form has an <code>AddBlock</code> functor, while the short form does not. In the short form, one of the arguments to <code>decompose</code> is <code>master</code>, and in the long form, provide <code>addblock</code> instead:</p>
<div class="fragment"><div class="line"><span class="comment">// in the short form, provide the master object in lieu of an AddBlock object</span></div>
<div class="line"><a class="code" href="group___decomposition.html#ga28dd3929d15d695bc73ed743dbbfef4e">diy::decompose</a>(dim,</div>
<div class="line">               rank,</div>
<div class="line">               domain,</div>
<div class="line">               assigner,</div>
<div class="line">               master);</div>
<div class="line"></div>
<div class="line"><span class="comment">// --- or ---</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// in the long form, provide the AddBlock object</span></div>
<div class="line"><a class="code" href="group___decomposition.html#ga28dd3929d15d695bc73ed743dbbfef4e">diy::decompose</a>(dim,</div>
<div class="line">               rank,</div>
<div class="line">               domain,</div>
<div class="line">               assigner,</div>
<div class="line">               addblock);</div>
</div><!-- fragment --><p>Strictly speaking, the second (long form) decomposition does not require an entire <code>AddBlock</code> object, as long as the block create function has the same signature as <code>AddBlock</code>. That pattern is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> create(<span class="keywordtype">int</span> gid,</div>
<div class="line">            <span class="keyword">const</span> Bounds&amp; core,</div>
<div class="line">            <span class="keyword">const</span> Bounds&amp; bounds,</div>
<div class="line">            <span class="keyword">const</span> Bounds&amp; domain,</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classdiy_1_1_link.html">diy::Link</a>&amp; link);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">diy::decompose(dim,</div>
<div class="line">               rank,</div>
<div class="line">               domain,</div>
<div class="line">               assigner,</div>
<div class="line">               create);</div>
</div><!-- fragment --><p> <code>decompose</code> is actually a convenience function that creates a <code>RegularDecomposer</code> object, calls its <code>decompose</code> method, and then destroys the <code>RegularDecomposer</code>. The user may want persistent access to <code>RegularDecomposer</code> because it offers useful information about the decomposition (block bounds, numbers of blocks in each dimension, and so forth.). In that case, we suggest defining <code>RegularDecomposer</code> and calling its <code>decompose</code> function yourself:</p>
<div class="fragment"><div class="line"><a class="code" href="structdiy_1_1_regular_decomposer.html">diy::RegularDecomposer&lt;Bounds&gt;</a> decomposer(dim,</div>
<div class="line">                                          domain,</div>
<div class="line">                                          nblocks);</div>
<div class="line"></div>
<div class="line"><span class="comment">// in the short form, use diy&#39;s AddBlock object</span></div>
<div class="line">decomposer.decompose(rank,</div>
<div class="line">                     assigner,</div>
<div class="line">                     diy::detail::AddBlock&lt;Bounds&gt;(&amp;master));</div>
<div class="line"></div>
<div class="line"><span class="comment">// --- or ---</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// in the long form, provide your own AddBlock object</span></div>
<div class="line">decomposer.decompose(rank,</div>
<div class="line">                     assigner,</div>
<div class="line">                     addblock);</div>
</div><!-- fragment --><h3>Put it all together.</h3>
<p>Here is one version of each of the above options combined into a complete program. This example uses the short form of blocks:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/decomposition.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/assigner.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="structdiy_1_1_bounds.html">diy::DiscreteBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularGridLink</a>      RGLink;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  Block() {}</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()            { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)    { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="structdiy_1_1mpi_1_1environment.html">diy::mpi::environment</a>     env(argc, argv);             <span class="comment">// diy&#39;s version of MPI_Init</span></div>
<div class="line">  <a class="code" href="classdiy_1_1mpi_1_1communicator.html">diy::mpi::communicator</a>    world;                       <span class="comment">// diy&#39;s version of MPI communicator</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span>                       dim     = 3;                 <span class="comment">// dimensionality</span></div>
<div class="line">  <span class="keywordtype">int</span>                       size    = 8;                 <span class="comment">// total number of MPI ranks</span></div>
<div class="line">  <span class="keywordtype">int</span>                       nblocks = 32;                <span class="comment">// total number of blocks in global domain</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_contiguous_assigner.html">diy::ContiguousAssigner</a>   assigner(size, nblocks);</div>
<div class="line">  Bounds domain;                                         <span class="comment">// global data size</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                            1,                           <span class="comment">// 1 thread in this example</span></div>
<div class="line">                            -1,                          <span class="comment">// all blocks in memory in this example</span></div>
<div class="line">                            &amp;Block::create,              <span class="comment">// block create function</span></div>
<div class="line">                            &amp;Block::destroy);            <span class="comment">// block destroy function</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="group___decomposition.html#ga28dd3929d15d695bc73ed743dbbfef4e">diy::decompose</a>(dim,</div>
<div class="line">                 world.rank(),                           <span class="comment">// MPI rank of this process</span></div>
<div class="line">                 domain,                                 <span class="comment">// global domain size</span></div>
<div class="line">                 assigner,                               <span class="comment">// assigner object</span></div>
<div class="line">                 master);                                <span class="comment">// master object</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Below is one more complete example, this time using the long form of the block:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;diy/decomposition.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/assigner.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;diy/master.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="structdiy_1_1_bounds.html">diy::DiscreteBounds</a>       Bounds;</div>
<div class="line"><span class="keyword">typedef</span>     <a class="code" href="classdiy_1_1_regular_link.html">diy::RegularGridLink</a>      RGLink;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Block</div>
<div class="line">{</div>
<div class="line">  Block() {}</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>*    create()            { <span class="keywordflow">return</span> <span class="keyword">new</span> Block; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span>     destroy(<span class="keywordtype">void</span>* b)    { <span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>Block*<span class="keyword">&gt;</span>(b); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>AddBlock</div>
<div class="line">{</div>
<div class="line">  AddBlock(<a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp; master_) : master(master_) {}</div>
<div class="line"></div>
<div class="line">  <span class="comment">// this is the function that is needed for diy::decompose</span></div>
<div class="line">  <span class="keywordtype">void</span>  operator()(<span class="keywordtype">int</span> gid,                              <span class="comment">// block global id</span></div>
<div class="line">                   <span class="keyword">const</span> Bounds&amp; core,                   <span class="comment">// block bounds without any ghost</span></div>
<div class="line">                   <span class="keyword">const</span> Bounds&amp; bounds,                 <span class="comment">// block bounds including ghost region</span></div>
<div class="line">                   <span class="keyword">const</span> Bounds&amp; domain,                 <span class="comment">// global data bounds</span></div>
<div class="line">                   <span class="keyword">const</span> RGLink&amp; link)                   <span class="comment">// communication neighborhood</span><span class="keyword"></span></div>
<div class="line"><span class="keyword">      const</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">          Block*          b   = <span class="keyword">new</span> Block();</div>
<div class="line">          RGLink*         l   = <span class="keyword">new</span> RGLink(link);</div>
<div class="line">          <a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp;    m   = <span class="keyword">const_cast&lt;</span><a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp;<span class="keyword">&gt;</span>(master);</div>
<div class="line">          <span class="keywordtype">int</span>             lid = m.<a class="code" href="classdiy_1_1_master.html#aeab2723bb0ecd4f7316b4805c1b53a61">add</a>(gid, b, l);        <span class="comment">// add block to the master (mandatory)</span></div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>&amp;  master;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="structdiy_1_1mpi_1_1environment.html">diy::mpi::environment</a>     env(argc, argv);             <span class="comment">// diy&#39;s version of MPI_Init</span></div>
<div class="line">  <a class="code" href="classdiy_1_1mpi_1_1communicator.html">diy::mpi::communicator</a>    world;                       <span class="comment">// diy&#39;s version of MPI communicator</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span>                       dim     = 3;                 <span class="comment">// dimensionality</span></div>
<div class="line">  <span class="keywordtype">int</span>                       size    = 8;                 <span class="comment">// total number of MPI ranks</span></div>
<div class="line">  <span class="keywordtype">int</span>                       nblocks = 32;                <span class="comment">// total number of blocks in global domain</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_contiguous_assigner.html">diy::ContiguousAssigner</a>   assigner(size, nblocks);</div>
<div class="line">  Bounds domain;                                         <span class="comment">// global data size</span></div>
<div class="line">  <a class="code" href="classdiy_1_1_master.html">diy::Master</a>               master(world,</div>
<div class="line">                            1,                           <span class="comment">// 1 thread in this example</span></div>
<div class="line">                            -1,                          <span class="comment">// all blocks in memory in this example</span></div>
<div class="line">                            &amp;Block::create,              <span class="comment">// block create function</span></div>
<div class="line">                            &amp;Block::destroy);            <span class="comment">// block destroy function</span></div>
<div class="line">  AddBlock                  addblock(master);            <span class="comment">// object for adding new blocks to master</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="group___decomposition.html#ga28dd3929d15d695bc73ed743dbbfef4e">diy::decompose</a>(dim,</div>
<div class="line">                 world.rank(),                           <span class="comment">// MPI rank of this process</span></div>
<div class="line">                 domain,                                 <span class="comment">// global domain size</span></div>
<div class="line">                 assigner,                               <span class="comment">// assigner object</span></div>
<div class="line">                 addblock);                              <span class="comment">// add block object</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Documentation about the <code>Master</code> object appears below. The <code>RegularDecomposer</code> is documented in the <a class="el" href="group___decomposition.html">Decomposition</a> page. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41e082628686ec3e798171b20ccced63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___initialization.html#ga41e082628686ec3e798171b20ccced63">diy::Master::Master</a> (mpi::communicator comm, int threads=1, int limit=-1, CreateBlock create=0, DestroyBlock destroy=0, ExternalStorage *storage=0, SaveBlock save=0, LoadBlock load=0, QueuePolicy *q_policy=new QueueSizePolicy(4096))</td></tr>
<tr class="memdesc:ga41e082628686ec3e798171b20ccced63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main DIY object.  <a href="#ga41e082628686ec3e798171b20ccced63">More...</a><br/></td></tr>
<tr class="separator:ga41e082628686ec3e798171b20ccced63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga41e082628686ec3e798171b20ccced63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">diy::Master::Master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdiy_1_1mpi_1_1communicator.html">mpi::communicator</a>&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CreateBlock&#160;</td>
          <td class="paramname"><em>create</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestroyBlock&#160;</td>
          <td class="paramname"><em>destroy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdiy_1_1_external_storage.html">ExternalStorage</a> *&#160;</td>
          <td class="paramname"><em>storage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SaveBlock&#160;</td>
          <td class="paramname"><em>save</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadBlock&#160;</td>
          <td class="paramname"><em>load</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdiy_1_1_master_1_1_queue_policy.html">QueuePolicy</a> *&#160;</td>
          <td class="paramname"><em>q_policy</em> = <code>new&#160;<a class="el" href="structdiy_1_1_master_1_1_queue_size_policy.html">QueueSizePolicy</a>(4096)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main DIY object. </p>
<p>Helper functions specify how to: create an empty block, destroy a block (a function that's expected to upcast and delete), serialize a block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>communicator </td></tr>
    <tr><td class="paramname">threads</td><td>number of threads DIY can use </td></tr>
    <tr><td class="paramname">limit</td><td>number of blocks to store in memory </td></tr>
    <tr><td class="paramname">create</td><td>block create function; master manages creation if create != 0 </td></tr>
    <tr><td class="paramname">destroy</td><td>block destroy function; master manages destruction if destroy != 0 </td></tr>
    <tr><td class="paramname">storage</td><td>storage object (path, method, etc.) for storing temporary blocks being shuffled in/out of core </td></tr>
    <tr><td class="paramname">save</td><td>block save function; master manages saving if save != 0 </td></tr>
    <tr><td class="paramname">load</td><td>block load function; master manages loading if load != 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 9 2017 17:12:23 for DIY by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
