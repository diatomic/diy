<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DIY: diy::Master::Proxy Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DIY
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">data-parallel out-of-core C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacediy.html">diy</a></li><li class="navelem"><a class="el" href="classdiy_1_1_master.html">Master</a></li><li class="navelem"><a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdiy_1_1_master_1_1_proxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">diy::Master::Proxy Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Communication proxy, used for enqueueing and dequeueing items for future exchange.  
 <a href="structdiy_1_1_master_1_1_proxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="proxy_8hpp_source.html">diy/proxy.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for diy::Master::Proxy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structdiy_1_1_master_1_1_proxy.png" usemap="#diy::Master::Proxy_map" alt=""/>
  <map id="diy::Master::Proxy_map" name="diy::Master::Proxy_map">
<area href="structdiy_1_1_master_1_1_proxy_with_link.html" alt="diy::Master::ProxyWithLink" shape="rect" coords="0,56,160,80"/>
<area href="structdiy_1_1_reduce_proxy.html" title="Enables communication within a group during a reduction. DIY creates the ReduceProxy for you in diy::..." alt="diy::ReduceProxy" shape="rect" coords="170,56,330,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy_1_1_enqueue_iterator.html">EnqueueIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adcf029a8640e8464e7d45cdb3cb1fc19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcf029a8640e8464e7d45cdb3cb1fc19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IncomingQueues</b> = std::map&lt; int, <a class="el" href="structdiy_1_1_memory_buffer.html">MemoryBuffer</a> &gt;</td></tr>
<tr class="separator:adcf029a8640e8464e7d45cdb3cb1fc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c285472a8e30cb3bae1a8b56ced2f54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c285472a8e30cb3bae1a8b56ced2f54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OutgoingQueues</b> = std::map&lt; <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a>, <a class="el" href="structdiy_1_1_memory_buffer.html">MemoryBuffer</a> &gt;</td></tr>
<tr class="separator:a8c285472a8e30cb3bae1a8b56ced2f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a877bc8f0e70b504840cad269682bb50f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877bc8f0e70b504840cad269682bb50f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Proxy</b> (<a class="el" href="classdiy_1_1_master.html">Master</a> *master__, int gid__, <a class="el" href="structdiy_1_1_master_1_1_i_exchange_info.html">IExchangeInfo</a> *iexchange__=0)</td></tr>
<tr class="separator:a877bc8f0e70b504840cad269682bb50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb70adf029ec12c107310f50b77cb38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb70adf029ec12c107310f50b77cb38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Proxy</b> (const <a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a> &amp;)=delete</td></tr>
<tr class="separator:aebb70adf029ec12c107310f50b77cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb501d689a2378f32ac3f7c187c1905"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb501d689a2378f32ac3f7c187c1905"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Proxy</b> (<a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a8fb501d689a2378f32ac3f7c187c1905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc1cf309dd486dda1f805ee07a26f95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cc1cf309dd486dda1f805ee07a26f95"></a>
<a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a> &amp;)=delete</td></tr>
<tr class="separator:a5cc1cf309dd486dda1f805ee07a26f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dea34a3d739608bc5f4cc180098cf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1dea34a3d739608bc5f4cc180098cf2"></a>
<a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structdiy_1_1_master_1_1_proxy.html">Proxy</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ab1dea34a3d739608bc5f4cc180098cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2497c6809ef06beb00dc14109edc3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb2497c6809ef06beb00dc14109edc3d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>gid</b> () const </td></tr>
<tr class="separator:acb2497c6809ef06beb00dc14109edc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86b06f0aa031d19aafa3cd003492a43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad86b06f0aa031d19aafa3cd003492a43"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_incoming</b> () const </td></tr>
<tr class="separator:ad86b06f0aa031d19aafa3cd003492a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752f60f14167a972c7e0519baa02e90"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1752f60f14167a972c7e0519baa02e90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy.html#a1752f60f14167a972c7e0519baa02e90">enqueue</a> (const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;to, const T &amp;x, void(*<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">save</a>)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, const T &amp;)=&amp;::<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a>) const </td></tr>
<tr class="memdesc:a1752f60f14167a972c7e0519baa02e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue data whose size can be determined automatically, e.g., an STL vector.  <a href="#a1752f60f14167a972c7e0519baa02e90">More...</a><br/></td></tr>
<tr class="separator:a1752f60f14167a972c7e0519baa02e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7862773e70ca24bdf8aab48d372e73"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acd7862773e70ca24bdf8aab48d372e73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy.html#acd7862773e70ca24bdf8aab48d372e73">enqueue</a> (const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;to, const T *x, size_t n, void(*<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">save</a>)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, const T &amp;)=&amp;::<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a>) const </td></tr>
<tr class="memdesc:acd7862773e70ca24bdf8aab48d372e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue data whose size is given explicitly by the user, e.g., an array.  <a href="#acd7862773e70ca24bdf8aab48d372e73">More...</a><br/></td></tr>
<tr class="separator:acd7862773e70ca24bdf8aab48d372e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2d7f947714e9641175b7da68d8d19b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c2d7f947714e9641175b7da68d8d19b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy.html#a1c2d7f947714e9641175b7da68d8d19b">dequeue</a> (int from, T &amp;x, void(*load)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)=&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>) const </td></tr>
<tr class="memdesc:a1c2d7f947714e9641175b7da68d8d19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue data whose size can be determined automatically (e.g., STL vector) and that was previously enqueued so that diy knows its size when it is received. In this case, diy will allocate the receive buffer; the user does not need to do so.  <a href="#a1c2d7f947714e9641175b7da68d8d19b">More...</a><br/></td></tr>
<tr class="separator:a1c2d7f947714e9641175b7da68d8d19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3bea4832995205378d7e81b5e5206b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7e3bea4832995205378d7e81b5e5206b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy.html#a7e3bea4832995205378d7e81b5e5206b">dequeue</a> (int from, T *x, size_t n, void(*load)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)=&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>) const </td></tr>
<tr class="memdesc:a7e3bea4832995205378d7e81b5e5206b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue an array of data whose size is given explicitly by the user. In this case, the user needs to allocate the receive buffer prior to calling dequeue.  <a href="#a7e3bea4832995205378d7e81b5e5206b">More...</a><br/></td></tr>
<tr class="separator:a7e3bea4832995205378d7e81b5e5206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15449e7b28db619d5749a925184ce86c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a15449e7b28db619d5749a925184ce86c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy.html#a15449e7b28db619d5749a925184ce86c">dequeue</a> (const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;from, T &amp;x, void(*load)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)=&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>) const </td></tr>
<tr class="memdesc:a15449e7b28db619d5749a925184ce86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue data whose size can be determined automatically (e.g., STL vector) and that was previously enqueued so that diy knows its size when it is received. In this case, diy will allocate the receive buffer; the user does not need to do so.  <a href="#a15449e7b28db619d5749a925184ce86c">More...</a><br/></td></tr>
<tr class="separator:a15449e7b28db619d5749a925184ce86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d59d96f1a7b7a6deca032f8eb2472a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8d59d96f1a7b7a6deca032f8eb2472a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdiy_1_1_master_1_1_proxy.html#ae8d59d96f1a7b7a6deca032f8eb2472a">dequeue</a> (const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;from, T *x, size_t n, void(*load)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)=&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a>) const </td></tr>
<tr class="memdesc:ae8d59d96f1a7b7a6deca032f8eb2472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue an array of data whose size is given explicitly by the user. In this case, the user needs to allocate the receive buffer prior to calling dequeue.  <a href="#ae8d59d96f1a7b7a6deca032f8eb2472a">More...</a><br/></td></tr>
<tr class="separator:ae8d59d96f1a7b7a6deca032f8eb2472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cb91e727f4b42566f7ee966dd25877"><td class="memTemplParams" colspan="2"><a class="anchor" id="a15cb91e727f4b42566f7ee966dd25877"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a15cb91e727f4b42566f7ee966dd25877"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdiy_1_1_master_1_1_proxy_1_1_enqueue_iterator.html">EnqueueIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enqueuer</b> (const T &amp;x, void(*<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">save</a>)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, const T &amp;)=&amp;::<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a>) const </td></tr>
<tr class="separator:a15cb91e727f4b42566f7ee966dd25877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caec3a819fbb8240f77ad4b81315b42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3caec3a819fbb8240f77ad4b81315b42"></a>
IncomingQueues *&#160;</td><td class="memItemRight" valign="bottom"><b>incoming</b> () const </td></tr>
<tr class="separator:a3caec3a819fbb8240f77ad4b81315b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea3bec714e4c206e5a1ae118844532c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea3bec714e4c206e5a1ae118844532c"></a>
<a class="el" href="structdiy_1_1_memory_buffer.html">MemoryBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>incoming</b> (int from) const </td></tr>
<tr class="separator:a8ea3bec714e4c206e5a1ae118844532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62cc563d913e28074656d7c6035b1c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae62cc563d913e28074656d7c6035b1c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>incoming</b> (std::vector&lt; int &gt; &amp;v) const </td></tr>
<tr class="separator:ae62cc563d913e28074656d7c6035b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c33b929864ee4185916df8236f66199"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c33b929864ee4185916df8236f66199"></a>
OutgoingQueues *&#160;</td><td class="memItemRight" valign="bottom"><b>outgoing</b> () const </td></tr>
<tr class="separator:a1c33b929864ee4185916df8236f66199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95822813073724a387523c52b2144a01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95822813073724a387523c52b2144a01"></a>
<a class="el" href="structdiy_1_1_memory_buffer.html">MemoryBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>outgoing</b> (const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;to) const </td></tr>
<tr class="separator:a95822813073724a387523c52b2144a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c73135d0bb99b1b5af98d9a392aa3b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c73135d0bb99b1b5af98d9a392aa3b5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty_incoming_queues</b> () const </td></tr>
<tr class="separator:a8c73135d0bb99b1b5af98d9a392aa3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4ba0a5ec50f4f4058b807cf99f8491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e4ba0a5ec50f4f4058b807cf99f8491"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty_outgoing_queues</b> () const </td></tr>
<tr class="separator:a4e4ba0a5ec50f4f4058b807cf99f8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb655d7f6e08d8724a52867750f3dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeb655d7f6e08d8724a52867750f3dcb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty_queues</b> () const </td></tr>
<tr class="separator:afeb655d7f6e08d8724a52867750f3dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce4381d1244875967dc3d127227bd45"><td class="memTemplParams" colspan="2">template&lt;class T , class Op &gt; </td></tr>
<tr class="memitem:gabce4381d1244875967dc3d127227bd45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#gabce4381d1244875967dc3d127227bd45">all_reduce</a> (const T &amp;<a class="el" href="namespacediy.html#a80c48a0054904994a271642ebec51608">in</a>, Op op) const </td></tr>
<tr class="memdesc:gabce4381d1244875967dc3d127227bd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an all-reduce collective using an existing communication proxy. Available operators are: maximum&lt;T&gt;, minimum&lt;T&gt;, std::plus&lt;T&gt;, std::multiplies&lt;T&gt;, std::logical_and&lt;T&gt;, and std::logical_or&lt;T&gt;.  <a href="group___communication.html#gabce4381d1244875967dc3d127227bd45">More...</a><br/></td></tr>
<tr class="separator:gabce4381d1244875967dc3d127227bd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e95469ec8128e4f4f4bcc20c2a6205"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga39e95469ec8128e4f4f4bcc20c2a6205"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga39e95469ec8128e4f4f4bcc20c2a6205"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#ga39e95469ec8128e4f4f4bcc20c2a6205">read</a> () const </td></tr>
<tr class="memdesc:ga39e95469ec8128e4f4f4bcc20c2a6205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of a proxy collective without popping it off the collectives list (same result would be returned multiple times). The list can be cleared with <a class="el" href="group___communication.html#gae3dbd9440a4a0b72abf3b8e35891c5d4" title="Return the list of proxy collectives (values and operations) ">collectives()</a>-&gt;clear(). <br/></td></tr>
<tr class="separator:ga39e95469ec8128e4f4f4bcc20c2a6205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ffa2d35209fbe7b2e9161e9fb79d96"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae5ffa2d35209fbe7b2e9161e9fb79d96"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5ffa2d35209fbe7b2e9161e9fb79d96"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___communication.html#gae5ffa2d35209fbe7b2e9161e9fb79d96">get</a> () const </td></tr>
<tr class="memdesc:gae5ffa2d35209fbe7b2e9161e9fb79d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of a proxy collective; result is popped off the collectives list. <br/></td></tr>
<tr class="separator:gae5ffa2d35209fbe7b2e9161e9fb79d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cf6d383cf53871e1cd9184ee274653"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6cf6d383cf53871e1cd9184ee274653"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af6cf6d383cf53871e1cd9184ee274653"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scratch</b> (const T &amp;<a class="el" href="namespacediy.html#a80c48a0054904994a271642ebec51608">in</a>) const </td></tr>
<tr class="separator:af6cf6d383cf53871e1cd9184ee274653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3dbd9440a4a0b72abf3b8e35891c5d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae3dbd9440a4a0b72abf3b8e35891c5d4"></a>
<a class="el" href="structdiy_1_1_master_1_1_collectives_list.html">CollectivesList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___communication.html#gae3dbd9440a4a0b72abf3b8e35891c5d4">collectives</a> () const </td></tr>
<tr class="memdesc:gae3dbd9440a4a0b72abf3b8e35891c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of proxy collectives (values and operations) <br/></td></tr>
<tr class="separator:gae3dbd9440a4a0b72abf3b8e35891c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca265396aa03208bd8f2e6e8dbfb2fc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca265396aa03208bd8f2e6e8dbfb2fc2"></a>
<a class="el" href="classdiy_1_1_master.html">Master</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>master</b> () const </td></tr>
<tr class="separator:aca265396aa03208bd8f2e6e8dbfb2fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f73eccc55f9166c7809be56fa491b0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f73eccc55f9166c7809be56fa491b0d"></a>
<a class="el" href="structdiy_1_1_master_1_1_i_exchange_info.html">IExchangeInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>iexchange</b> () const </td></tr>
<tr class="separator:a6f73eccc55f9166c7809be56fa491b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Communication proxy, used for enqueueing and dequeueing items for future exchange. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="reduce_2sample-sort_8cpp-example.html#_a1">reduce/sample-sort.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1c2d7f947714e9641175b7da68d8d19b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void diy::Master::Proxy::dequeue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)&#160;</td>
          <td class="paramname"><em>load</em> = <code>&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue data whose size can be determined automatically (e.g., STL vector) and that was previously enqueued so that diy knows its size when it is received. In this case, diy will allocate the receive buffer; the user does not need to do so. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>target block gid </td></tr>
    <tr><td class="paramname">x</td><td>data (eg. STL vector) </td></tr>
    <tr><td class="paramname">load</td><td>optional serialization function </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="reduce_2all-done_8cpp-example.html#a11">reduce/all-done.cpp</a>, <a class="el" href="reduce_2kd-tree_8cpp-example.html#a21">reduce/kd-tree.cpp</a>, <a class="el" href="reduce_2merge-reduce_8cpp-example.html#a15">reduce/merge-reduce.cpp</a>, <a class="el" href="reduce_2sort_8cpp-example.html#a14">reduce/sort.cpp</a>, <a class="el" href="reduce_2swap-reduce_8cpp-example.html#a10">reduce/swap-reduce.cpp</a>, and <a class="el" href="simple_2simple_8cpp-example.html#a10">simple/simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7e3bea4832995205378d7e81b5e5206b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diy::Master::Proxy::dequeue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)&#160;</td>
          <td class="paramname"><em>load</em> = <code>&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue an array of data whose size is given explicitly by the user. In this case, the user needs to allocate the receive buffer prior to calling dequeue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>target block gid </td></tr>
    <tr><td class="paramname">x</td><td>pointer to the data (eg. address of start of vector) </td></tr>
    <tr><td class="paramname">n</td><td>size in data elements (eg. ints) </td></tr>
    <tr><td class="paramname">load</td><td>optional serialization function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15449e7b28db619d5749a925184ce86c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void diy::Master::Proxy::dequeue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)&#160;</td>
          <td class="paramname"><em>load</em> = <code>&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue data whose size can be determined automatically (e.g., STL vector) and that was previously enqueued so that diy knows its size when it is received. In this case, diy will allocate the receive buffer; the user does not need to do so. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>target block (gid,proc) </td></tr>
    <tr><td class="paramname">x</td><td>data (eg. STL vector) </td></tr>
    <tr><td class="paramname">load</td><td>optional serialization function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8d59d96f1a7b7a6deca032f8eb2472a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void diy::Master::Proxy::dequeue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, T &amp;)&#160;</td>
          <td class="paramname"><em>load</em> = <code>&amp;::<a class="el" href="group___serialization.html#gae54f4c5c6740fcf7627009bdcfe02aa1">diy::load</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeue an array of data whose size is given explicitly by the user. In this case, the user needs to allocate the receive buffer prior to calling dequeue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>target block (gid,proc) </td></tr>
    <tr><td class="paramname">x</td><td>pointer to the data (eg. address of start of vector) </td></tr>
    <tr><td class="paramname">n</td><td>size in data elements (eg. ints) </td></tr>
    <tr><td class="paramname">load</td><td>optional serialization function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1752f60f14167a972c7e0519baa02e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void diy::Master::Proxy::enqueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, const T &amp;)&#160;</td>
          <td class="paramname"><em>save</em> = <code>&amp;::<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue data whose size can be determined automatically, e.g., an STL vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>target block (gid,proc) </td></tr>
    <tr><td class="paramname">x</td><td>data (eg. STL vector) </td></tr>
    <tr><td class="paramname">save</td><td>optional serialization function </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="reduce_2all-done_8cpp-example.html#a9">reduce/all-done.cpp</a>, <a class="el" href="reduce_2all-to-all_8cpp-example.html#a10">reduce/all-to-all.cpp</a>, <a class="el" href="reduce_2kd-tree_8cpp-example.html#a17">reduce/kd-tree.cpp</a>, <a class="el" href="reduce_2merge-reduce_8cpp-example.html#a17">reduce/merge-reduce.cpp</a>, <a class="el" href="reduce_2sort_8cpp-example.html#a10">reduce/sort.cpp</a>, <a class="el" href="reduce_2swap-reduce_8cpp-example.html#a13">reduce/swap-reduce.cpp</a>, and <a class="el" href="simple_2simple_8cpp-example.html#a5">simple/simple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acd7862773e70ca24bdf8aab48d372e73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diy::Master::Proxy::enqueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdiy_1_1_block_i_d.html">BlockID</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structdiy_1_1_binary_buffer.html">BinaryBuffer</a> &amp;, const T &amp;)&#160;</td>
          <td class="paramname"><em>save</em> = <code>&amp;::<a class="el" href="group___serialization.html#gafaac9aa4ccdc04930f612ca20341fc9b">diy::save</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue data whose size is given explicitly by the user, e.g., an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>target block (gid,proc) </td></tr>
    <tr><td class="paramname">x</td><td>pointer to the data (eg. address of start of vector) </td></tr>
    <tr><td class="paramname">n</td><td>size in data elements (eg. ints) </td></tr>
    <tr><td class="paramname">save</td><td>optional serialization function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/diy/<a class="el" href="proxy_8hpp_source.html">proxy.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 12 2020 21:07:38 for DIY by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
